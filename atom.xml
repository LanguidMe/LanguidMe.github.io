<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://languidme.github.io/</id>
    <title>Gridea</title>
    <updated>2019-08-02T10:27:55.053Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://languidme.github.io/"/>
    <link rel="self" href="https://languidme.github.io//atom.xml"/>
    <subtitle>æ¸©æ•…è€ŒçŸ¥æ–°</subtitle>
    <logo>https://languidme.github.io//images/avatar.png</logo>
    <icon>https://languidme.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[nettyæºç åˆ†ææµç¨‹(ä¸€)]]></title>
        <id>https://languidme.github.io//post/netty-yuan-ma-fen-xi-liu-cheng-yi</id>
        <link href="https://languidme.github.io//post/netty-yuan-ma-fen-xi-liu-cheng-yi">
        </link>
        <updated>2019-08-02T08:45:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1ç¯å¢ƒ">1.ç¯å¢ƒ</h3>
<ul>
<li>æ­¤æ¬¡é¡¹ç›®åˆ†æéƒ½æ˜¯åŸºäºNettyï¼š<code>4.1.X</code>ç‰ˆæœ¬</li>
<li>é¦–å…ˆåœ¨githubè¿›è¡Œforkä¸€ä»½åˆ°è‡ªå·±çš„ä»“åº“ï¼Œå¦‚æœè®¿é—®githubæ¯”è¾ƒæ…¢ï¼Œå¯ä»¥ä½¿ç”¨<code>ç äº‘</code>copyåˆ°è‡ªå·±çš„ç äº‘ä»“åº“</li>
<li>ç¯å¢ƒæ­å»ºæ¯”è¾ƒç®€å•è¿™é‡Œå°±ä¸åšæ¼”ç¤ºäº†</li>
</ul>
<h3 id="2æºç åˆ†æ">2.æºç åˆ†æ</h3>
<p>â€‹	é¦–å…ˆæ‰“å¼€å®˜æ–¹çš„Demo(<strong>æ³¨æ„è¿™é‡Œåªåˆ†ææµç¨‹,è¯¦ç»†çš„ç±»è§£æ,åé¢ä¼šå‡º</strong>)</p>
<p><img src="https://gitee.com/waitShe/images/raw/master/blog/1560842808589.png" alt="avatar"></p>
<ul>
<li>
<p>é¦–å…ˆè´´å‡ºæ¥Serverç«¯çš„ä»£ç ,è¿™ä¸ªå¤§éƒ¨åˆ†äººåŸºæœ¬éƒ½ç†Ÿæ‚‰</p>
<pre><code class="language-java">public final class EchoServer {
    static final int PORT = Integer.parseInt(System.getProperty(&quot;port&quot;, &quot;8007&quot;));

    public static void main(String[] args) throws Exception {
        // 1
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        final EchoServerHandler serverHandler = new EchoServerHandler();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                // 2
             .channel(NioServerSocketChannel.class)
             .option(ChannelOption.SO_BACKLOG, 100)
             .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
                     ChannelPipeline p = ch.pipeline();
                     p.addLast(serverHandler);
                 }
             });
            // 3
            ChannelFuture f = b.bind(PORT).sync();
            f.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
</code></pre>
</li>
</ul>
<h4 id="ç¬¬ä¸€æ­¥åˆ†æeventloopgroup-bossgroup-new-nioeventloopgroup1æ­¤å¯¹è±¡çš„æ„å»º">ç¬¬ä¸€æ­¥,åˆ†æ<code>EventLoopGroup bossGroup = new NioEventLoopGroup(1);</code>æ­¤å¯¹è±¡çš„æ„å»º</h4>
<p>é¦–å…ˆçœ‹åçŸ¥å…¶æ„<code>NIOäº‹ä»¶å¾ªç¯ç»„</code>,æ—¢ç„¶æ˜¯ç»„é‚£ä¹ˆåç»­è‚¯å®šä¼šæœ‰<code>NioEventLoop</code>è¿™æ ·ç±»çš„æ•°ç»„,è¿™é‡Œæ˜¯bossGroupè®¾ç½®çš„çº¿ç¨‹æ•°ä¸º1,æ‰€ä»¥å¤§æ¦‚çŒœæµ‹<code>NioEventLoopGroup</code>ä¸­åº”è¯¥æœ‰ä¸€ä¸ª<code>NioEventLoop</code>æ•°ç»„å¹¶ä¸”æ•°ç»„å¤§å°ç­‰äº1</p>
<ul>
<li>é¦–å…ˆç»™ä¸ªç±»å›¾</li>
</ul>
<p><img src="https://gitee.com/waitShe/images/raw/master/blog/NioEventLoopGroup%E7%B1%BB%E5%9B%BE.png" alt=""></p>
<ul>
<li>ä¸ªäººå»ºè®®è¿˜æ˜¯å…ˆçœ‹ä¸€ä¸‹<code>EventLoopGroup</code>å’Œ<code>EventExecutorGroup</code>é¡¶çº§æ¥å£çš„æ–¹æ³•,æœ€èµ·ç èƒ½çŸ¥é“å¤§è‡´è¿™äº›ç±»å¹²ä»€ä¹ˆç”¨çš„</li>
</ul>
<p><strong>è‡³äºworkerGroupåˆ™ä½¿ç”¨é»˜è®¤çš„å¤§å°</strong>ï¼Œä¸‹é¢è´´å‡º<code>NioEventLoopGroup</code>æ–¹æ³•</p>
<pre><code class="language-java">public NioEventLoopGroup(int nThreads) {
    this(nThreads, (Executor) null);
}
public NioEventLoopGroup(int nThreads, Executor executor) {
    this(nThreads, executor, SelectorProvider.provider());
}
public NioEventLoopGroup(
            int nThreads, Executor executor, final SelectorProvider selectorProvider) {
    this(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);
}
public NioEventLoopGroup(int nThreads, Executor executor, final SelectorProvider selectorProvider,
                             final SelectStrategyFactory selectStrategyFactory) {
    super(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());
}
// å®ç°çˆ¶ç±»æ–¹æ³•
@Override
protected EventLoop newChild(Executor executor, Object... args) throws Exception {
    return new NioEventLoop(this, executor, (SelectorProvider) args[0],
                            ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);
}
</code></pre>
<ul>
<li>è§£æ<code>MultithreadEventLoopGroup</code>ç±»åœ¨æµç¨‹ä¸­æ¯”è¾ƒé‡è¦çš„æ–¹æ³•</li>
</ul>
<pre><code class="language-java">// æ„é€ æ–¹æ³• MultithreadEventLoopGroup
protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {
    // DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(&quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));
    // å¦‚æœnThreadsæ²¡æœ‰è®¾ç½®å€¼,é»˜è®¤å–å€¼DEFAULT_EVENT_LOOP_THREADS:å¦‚æœå¯åŠ¨å‚æ•°è®¾ç½®-Dio.netty.eventLoopThreadsåˆ™å–è¿™ä¸ªå€¼ï¼Œå¦åˆ™å–å¯ç”¨å¤„ç†å™¨*2
    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
}
@Override
protected ThreadFactory newDefaultThreadFactory() {
    return new DefaultThreadFactory(getClass(), Thread.MAX_PRIORITY);
}

@Override
public EventLoop next() {
    return (EventLoop) super.next();
}

@Override
protected abstract EventLoop newChild(Executor executor, Object... args) throws Exception;
	
</code></pre>
<pre><code>	* åœ¨è§£æ`MultithreadEventExecutorGroup`æ–¹æ³•
</code></pre>
<pre><code class="language-java">// MultithreadEventExecutorGroupæ„é€ æ–¹æ³•(è¿™äº›å‚æ•°è‚¯å®šæ˜¯è¦å­˜æ”¾åˆ°çˆ¶ç±»ä¸­æ‰åˆé€‚)
protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) {
    this(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);
}
protected MultithreadEventExecutorGroup(int nThreads, Executor executor,
                                            EventExecutorChooserFactory chooserFactory, Object... args) {
	if (executor == null) {
		// å¦‚æœexecutorç­‰äºnull åˆ™åˆ›å»ºThreadPerTaskExecutorå¯¹è±¡,
		// ThreadPerTaskExecutorå»æ‰§è¡ŒDefaultThreadFactoryåˆ›å»ºå‡ºæ¥çš„çº¿ç¨‹
		// è¿™é‡Œå°±ä½“ç°å‡ºäº†å·¥å‚æ¨¡å¼ DefaultThreadFactory åˆ›å»ºçº¿ç¨‹å·¥å‚
		executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
	}
	// è¿™é‡Œæ„å»ºEventExecutorå¯¹è±¡æ•°ç»„,è¿™ä¸ªå¯¹è±¡çš„å­ç±»å¤§è‡´çŒœæµ‹ä¸€ä¸‹,è‚¯å®šä¼šæœ‰ä¸Šé¢æåˆ°çš„NioEventLoop
	// æ‰€ä»¥è¿™é‡Œä¹Ÿå¯ä»¥ å½“æˆ children = new NioEventLoop[nThreads];
	// bossGroupçš„nThreads æ˜¯1
	children = new EventExecutor[nThreads];
	for (int i = 0; i &lt; nThreads; i ++) {
		boolean success = false;
		try {
            // è¿™é‡Œå°±æ˜¯è°ƒç”¨äº†NioEventLoopGroupçš„å®ç°æ–¹æ³•åˆ›å»ºäº†NioEventLoopå¯¹è±¡
			children[i] = newChild(executor, args);
			success = true;
		} catch (Exception e) {
			throw new IllegalStateException(&quot;failed to create a child event loop&quot;, e);
		} finally {
			// å¦‚æœå¤±è´¥äº†åˆ™ä¼šæ‰§è¡Œå…³é—­
			if (!success) {
				for (int j = 0; j &lt; i; j ++) {
					children[j].shutdownGracefully();
				}
				for (int j = 0; j &lt; i; j ++) {
					EventExecutor e = children[j];
					try {
						while (!e.isTerminated()) {
							e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
						}
					} catch (InterruptedException interrupted) {
						Thread.currentThread().interrupt();
						break;
					}
				}
			}
		}
	}
	// åˆ›å»ºé€‰æ‹©æ‰§è¡Œå™¨,ç®€å•ç†è§£å°±æ˜¯ï¼šnew NioEventLoop[nThreads] æ˜¯ä¸ªæ•°ç»„,æŒ‰ç…§ä»€ä¹ˆè§„åˆ™è·å–ä¸‹ä¸€ä¸ªNioEventLoopå»æ‰§è¡Œ
	// çœ‹ä¸‹nextæ–¹æ³•å°±æ˜ç™½äº†
	chooser = chooserFactory.newChooser(children);
	final FutureListener&lt;Object&gt; terminationListener = new FutureListener&lt;Object&gt;() {
		@Override
		public void operationComplete(Future&lt;Object&gt; future) throws Exception {
			if (terminatedChildren.incrementAndGet() == children.length) {
				terminationFuture.setSuccess(null);
			}
		}
	};
	for (EventExecutor e: children) {
		// è®¾ç½®childrenï¼ˆSingleThreadEventLoopï¼‰çš„ç›‘å¬å™¨-ç”¨äºç›‘å¬å…³é—­çº¿ç¨‹æ‰§è¡Œå™¨
		e.terminationFuture().addListener(terminationListener);
	}
	Set&lt;EventExecutor&gt; childrenSet = new LinkedHashSet&lt;EventExecutor&gt;(children.length);
	Collections.addAll(childrenSet, children);
	// è®¾ç½®æˆä¸å¯ä¿®æ”¹çš„List
	readonlyChildren = Collections.unmodifiableSet(childrenSet);
}
// ä½¿ç”¨é€‰æ‹©å™¨è·å–ä¸‹ä¸€ä¸ªæ‰§è¡Œå™¨
@Override
public EventExecutor next() {
    return chooser.next();
}

@Override
public Iterator&lt;EventExecutor&gt; iterator() {
    return readonlyChildren.iterator();
}
// æ­¤ç±»åˆ«çš„æ–¹æ³•å°±ä¸ä»‹ç»äº†,è‡ªå·±å¯ä»¥å»çœ‹ä¸€çœ‹
</code></pre>
<h4 id="ä¸‹é¢çœ‹serverä¸­çš„ç¬¬äºŒè¡Œæ ‡è®°ä»£ç channelnioserversocketchannelclass">ä¸‹é¢çœ‹Serverä¸­çš„ç¬¬äºŒè¡Œæ ‡è®°ä»£ç <code>.channel(NioServerSocketChannel.class)</code></h4>
<pre><code class="language-java">public B channel(Class&lt;? extends C&gt; channelClass) {
	return channelFactory(new ReflectiveChannelFactory&lt;C&gt;(
			ObjectUtil.checkNotNull(channelClass, &quot;channelClass&quot;)
	));
}
// æ³¨æ„:io.netty.channel.ChannelFactoryæ˜¯ChannelFactoryçš„å­ç±»
public B channelFactory(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory) {
	return channelFactory((ChannelFactory&lt;C&gt;) channelFactory);
}
public B channelFactory(ChannelFactory&lt;? extends C&gt; channelFactory) {
	this.channelFactory = channelFactory;
	return self();
}
</code></pre>
<p>ä»ä»£ç ä¸­ä¸éš¾çœ‹å‡ºåˆæ˜¯ä¸€ä¸ªå·¥å‚ç±»,<code>ReflectiveChannelFactory</code>ç»™ä»€ä¹ˆæ ·çš„channel classä¼šç”Ÿæˆè¿™ä¸ªå¯¹è±¡</p>
<pre><code class="language-java">// ReflectiveChannelFactoryç±»ä»£ç 
public class ReflectiveChannelFactory&lt;T extends Channel&gt; implements ChannelFactory&lt;T&gt; {
    private final Constructor&lt;? extends T&gt; constructor;
	
    public ReflectiveChannelFactory(Class&lt;? extends T&gt; clazz) {
        this.constructor = clazz.getConstructor();
    }

    @Override
    public T newChannel() {
        return constructor.newInstance();
    }
}
</code></pre>
<p>ç®€åŒ–åçš„ä»£ç å¾ˆç®€å•,è¿™é‡Œå°±ä¸å¤šè¯´äº†ï¼Œå·¥å‚å°±æ˜¯æ–¹ä¾¿äº†ä¼ å…¥ä»€ä¹ˆå°±ç”Ÿæˆä»€ä¹ˆ,ä¼ å…¥çš„nioé‚£ä¹ˆchannelæ˜¯nio,nettyä¸»è¦ç”¨äºnioï¼Œæ‰€ä»¥è¿™é‡Œåªè¯´<code>NioServerSocketChannel</code></p>
<ul>
<li>
<p>å·¥å‚ç±»æ²¡ä»€ä¹ˆè¯´çš„äº†,å°±è¦çœ‹ä¸€ä¸‹<code>NioServerSocketChannel</code>ç±»äº†å§,ç›´æ¥ä¸Šä»£ç å§</p>
<p>å…ˆåªéœ€è¦çœ‹å¯¹è±¡çš„æ„é€ æ–¹æ³•å³å¯,åˆ«çš„æ–¹æ³•æœ‰ä¸ªè®°å¿†å°±è¡Œ,èµ°bindæ–¹æ³•åˆ†æçš„æ—¶å€™ä¼šè°ƒç”¨è¿™äº›æ–¹æ³•</p>
</li>
</ul>
<pre><code class="language-java">public class NioServerSocketChannel extends AbstractNioMessageChannel
                             implements io.netty.channel.socket.ServerSocketChannel {
	/**
	* åªä¿ç•™äº†éƒ¨åˆ†æ–¹æ³•,å…¶ä½™æ–¹æ³•å¯è‡ªè¡Œè§‚çœ‹å¹¶äº†è§£
	* æ­¤ç±»è¿˜éœ€è¦æ³¨æ„çš„æ˜¯ç»§æ‰¿çš„AbstractNioMessageChannel,çˆ¶ç±»AbstractNioMessageChannelä¸­æœ‰å†…éƒ¨ç±»NioMessageUnsafe
	* ç”¨äºå¯¹æ¶ˆæ¯çš„å¤„ç†,å¤„ç†å¤§è‡´æµç¨‹,å°±æ˜¯æŠŠè¯»å†™æ“ä½œäº¤ç»™workerGroupå»å¤„ç†,NioMessageUnsafeä¼šæŠŠchannelå°è£…æˆNioSocketChannelå¯¹è±¡
	* ä»¥ä¾¿äºwokerGroupå»å¤„ç†
	*/
    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
	// SelectorProvider.provider() å°±ä¸å¤šè¯´äº†,ä¸çŸ¥é“çš„å¯ä»¥å»çœ‹ä¸‹NIOçš„demoçŸ¥é“è¿™ä¸ªå¹²ä»€ä¹ˆç”¨çš„å°±è¡Œ
	// è¿™é‡Œå­˜å‚¨ä¸ºå…¨å‘˜å˜é‡ æ˜¯å› ä¸ºSelectorProvider.provider()æ­¤æ–¹æ³•é‡Œé¢æœ‰åŒæ­¥ä»£ç å—.åŒæ­¥è‚¯å®šä¼šå½±å“é€Ÿåº¦
    private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();

    private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioServerSocketChannel.class);

	// æ‰“å¼€ä¸€ä¸ªSocketé€šé“
    private static ServerSocketChannel newSocket(SelectorProvider provider) {
        return provider.openServerSocketChannel();
    }

    private final ServerSocketChannelConfig config;

    public NioServerSocketChannel() {
        this(newSocket(DEFAULT_SELECTOR_PROVIDER));
    }

    public NioServerSocketChannel(SelectorProvider provider) {
        this(newSocket(provider));
    }

    public NioServerSocketChannel(ServerSocketChannel channel) {
		// SelectionKey.OP_ACCEPT è¿™ä¸€è¡Œäº†è§£ç½‘ä¸ŠNIO Demoçš„è‚¯å®šæ¸…æ¥š
		// è¿™é‡Œå°±è¯´æ˜äº†bossGroupæ˜¯åªè´Ÿè´£å’Œå®¢æˆ·ç«¯çš„è¿æ¥
        super(null, channel, SelectionKey.OP_ACCEPT);
        config = new NioServerSocketChannelConfig(this, javaChannel().socket());
    }

    @Override
    protected void doBind(SocketAddress localAddress) throws Exception {
		// Javaç‰ˆæœ¬æ˜¯å¦ &gt;= 7 åº”è¯¥æ˜¯ç‰ˆæœ¬ä¸åŒ  bindæ–¹æ³•çš„ä½¿ç”¨ä¸åŒ(æœ¬äººæ¸£æ¸£,æ°´å¹³æœ‰é™(*^â–½^*))
        if (PlatformDependent.javaVersion() &gt;= 7) {
            javaChannel().bind(localAddress, config.getBacklog());
        } else {
            javaChannel().socket().bind(localAddress, config.getBacklog());
        }
    }
	
	// æ­¤æ–¹æ³•å¾ˆé‡è¦,å½“Serverè¿æ¥å¥½å®¢æˆ·ç«¯åå‘ç”Ÿäº†è¯»äº‹ä»¶,å°±ä¼šè°ƒç”¨æ­¤æ–¹æ³•
    @Override
    protected int doReadMessages(List&lt;Object&gt; buf) throws Exception {
        SocketChannel ch = SocketUtils.accept(javaChannel());
        try {
            if (ch != null) {
                buf.add(new NioSocketChannel(this, ch));
                return 1;
            }
        } catch (Throwable t) {
        }
        return 0;
    }
}
</code></pre>
<h4 id="åˆ†ææœ€é‡è¦çš„ä¹Ÿæ˜¯æœ€éš¾çš„ä¸€è¡Œä»£ç channelfuture-f-bbindportsync">åˆ†ææœ€é‡è¦çš„ä¹Ÿæ˜¯æœ€éš¾çš„ä¸€è¡Œä»£ç <code>ChannelFuture f = b.bind(PORT).sync();</code></h4>
<ul>
<li>b å°±æ˜¯ <code>ServerBootStrap</code></li>
</ul>
<pre><code class="language-java">// çˆ¶ç±»AbstractBootStrap
public ChannelFuture bind(int inetPort) {
	return bind(new InetSocketAddress(inetPort));
}
public ChannelFuture bind(SocketAddress localAddress) {
	return doBind(ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;));
}

private ChannelFuture doBind(final SocketAddress localAddress) {
	// NO.1 åˆå§‹åŒ–å’Œæ³¨å†Œchannel
	final ChannelFuture regFuture = initAndRegister();
	final Channel channel = regFuture.channel();
	if (regFuture.cause() != null) {
		return regFuture;
	}
	if (regFuture.isDone()) {
		// è¡¨ç¤ºæ³¨å†Œå·²ç»å®Œæˆ(è¿™é‡Œçš„æ³¨å†ŒæŒ‡çš„æ˜¯channelæ³¨å†Œåˆ°selectorä¸Š)
		ChannelPromise promise = channel.newPromise();
		doBind0(regFuture, channel, localAddress, promise);
		return promise;
	} else {
		// å½“æ²¡æœ‰å®Œæˆæ—¶è¿›è¡Œæ„å»ºéœ€è¦çš„å‚æ•°
		final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
		regFuture.addListener(new ChannelFutureListener() {
			@Override
			public void operationComplete(ChannelFuture future) throws Exception {
				Throwable cause = future.cause();
				if (cause != null) {
					// æ³¨å†Œå¤±è´¥çš„å¤„ç†
					promise.setFailure(cause);
				} else {
					// æ³¨å†ŒæˆåŠŸ
					// See https://github.com/netty/netty/issues/2586
					promise.registered();
					// NO.2 æ³¨å†ŒæˆåŠŸåè¿›è¡Œç»‘å®š
					doBind0(regFuture, channel, localAddress, promise);
				}
			}
		});
		return promise;
	}
}
</code></pre>
<h5 id="åˆ†æno1-final-channelfuture-regfuture-initandregister">åˆ†æNO.1 <code>final ChannelFuture regFuture = initAndRegister();</code></h5>
<ul>
<li>ä¹Ÿæ˜¯çˆ¶ç±»AbstractBootStrap</li>
</ul>
<pre><code class="language-java">final ChannelFuture initAndRegister() {
	// æ–¹æ³•ç»™ç®€åŒ–äº†
	Channel channel = null;
	// è°ƒç”¨å·¥å‚åˆ›å»ºchannel(ä¹Ÿå°±æ˜¯ä¸Šé¢çš„NioServerSocketChannel),è¿™é‡Œéœ€è¦å’Œä¸Šé¢è”ç³»èµ·æ¥
	channel = channelFactory.newChannel();
	// åˆå§‹åŒ–channel
	init(channel);
	// æ³¨å†Œchannelåˆ°selectorä¸Š
	ChannelFuture regFuture = config().group().register(channel);
	return regFuture;
}
</code></pre>
<ul>
<li>åˆå§‹åŒ–initæ–¹æ³•çŒœæµ‹ä¸€ä¸‹è‚¯å®šæ˜¯ä¸ªæŠ½è±¡æ–¹æ³•æ‰€ä»¥å®ç°åœ¨å­ç±»<code>ServerBootStrap</code></li>
</ul>
<pre><code class="language-java">// ServerBootStrap.init()
void init(Channel channel) throws Exception {
	final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();
	synchronized (options) {
		setChannelOptions(channel, options, logger);
    }
	final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();
	synchronized (attrs) {
		for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) {
			AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();
			channel.attr(key).set(e.getValue());
		}
	}
	// ä¸Šé¢è®¾ç½®æ˜¯è®¾ç½®ä¸€äº›å‚æ•°,å°±ä¸å¤šè¯´äº†

	ChannelPipeline p = channel.pipeline();
	
	// ä¸‹é¢çš„æ“ä½œéƒ½æ˜¯å¯¹childGroupä¹Ÿå°±æ˜¯workerGroupè¿›è¡Œçš„æ“ä½œ
	final EventLoopGroup currentChildGroup = childGroup;
	final ChannelHandler currentChildHandler = childHandler;
	final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;
	final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;
	synchronized (childOptions) {
		currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));
	}
	synchronized (childAttrs) {
		currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));
	}
	
	// ç»™bossGroupæ·»åŠ å¤„ç†é“¾
	p.addLast(new ChannelInitializer&lt;Channel&gt;() {
		@Override
		public void initChannel(final Channel ch) throws Exception {
			final ChannelPipeline pipeline = ch.pipeline();
			ChannelHandler handler = config.handler();
			if (handler != null) {
				pipeline.addLast(handler);
			}
			// ch.eventLoop æ˜¯bossGroupçš„
			ch.eventLoop().execute(new Runnable() {
				@Override
				public void run() {
					// è¿™é‡Œç»™bossGroupæ·»åŠ ä¸€ä¸ªå¤„ç†é“¾ç±»,è¿™é‡Œä¼ çš„å˜é‡èƒ½çœ‹çš„å‡ºæ¥åŸºæœ¬éƒ½æ˜¯Child,æ‰€ä»¥å¤§èƒ†çŒœæµ‹ä¸€ä¸‹
					// ServerBootstrapAcceptorè¿™ä¸ªç±»å°±æ˜¯ç”¨æ¥å¤„ç†wokerGroupçš„ä¹Ÿå°±æ˜¯è¯´ç”¨äºå¤„ç†`è¯»å†™`æ“ä½œçš„
					// å‰é¢ä¹Ÿè¯´äº†,bossGroupåªç”¨äºå¤„ç†å’Œå®¢æˆ·ç«¯çš„è¿æ¥
                    // æ›´åŠ å‡†ç¡®ç‚¹è¯´,ServerBootstrapAcceptorè¿™ä¸ªç±»æ›´åƒæ˜¯ä¸€ä¸ªå§”æ‰˜ç±»,å§”æ‰˜ç»™ServerBootstrapAcceptoræ­¤ç±»è¿›è¡Œå¯¹wokerGroupæ“ä½œ
					pipeline.addLast(new ServerBootstrapAcceptor(
							ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
				}
			});
		}
	});
}
</code></pre>
<ul>
<li>
<p>ç„¶åæ¥ç€çœ‹<code>ChannelFuture regFuture = config().group().register(channel);</code>è¿™è¡Œæ–¹æ³•</p>
<ul>
<li>
<p><code>config().group()</code> å°±æ˜¯è°ƒç”¨çš„bossGroupå¯ä»¥æ¥ç€è·Ÿå…¥</p>
<p>ä¼šè¿›å…¥åˆ°<code>SingleThreadEventLoop</code>ç±»ä¸­,æ­¤ç±»å°±æ˜¯<code>NioEventLoop</code>çš„çˆ¶ç±»,å¦‚æœæƒ³ä¸èµ·çš„å¯ä»¥çœ‹ä¸€ä¸‹ä¸Šé¢è¯´è¿‡çš„newChildæ–¹æ³•</p>
<pre><code class="language-java">// SingleThreadEventLoop
public ChannelFuture register(Channel channel) {
	// DefaultChannelPromise æ­¤ç±»å¯ä»¥ç†è§£æˆä¸€ä¸ªå›è°ƒç±»,å½“æ‰§è¡ŒæˆåŠŸæŸäº›æ“ä½œå,ä¼šå›è°ƒæ­¤ç±»çš„æŸä¸ªå‡½æ•°(æ–¹æ³•)
	// å…¶å®æœ‰ç‚¹åƒjsçš„å›è°ƒå‡½æ•°ä¸€æ · psï¼šæœ¬äººè‡ªå·±çš„ç†è§£,å¦‚æœ‰é”™è¯¯,è¯·æŒ‡å‡ºå¤šè°¢
	return register(new DefaultChannelPromise(channel, this));
}

public ChannelFuture register(final ChannelPromise promise) {
	// promise.channel() å°±æ˜¯NioServerSocketChannel
	// unsafe()å°±æ˜¯Unsafeç±»,åªä¸è¿‡æ˜¯å…¶å®ç°ç±» 
	// registeræ–¹æ³•è°ƒç”¨çš„æ˜¯é¡¶çº§æŠ½è±¡ç±»AbstractUnsafe(å®ç°äº†Unsafe)
	// è¿™é‡Œçš„thiså°±æ˜¯bossGroup
	promise.channel().unsafe().register(this, promise);
	return promise;
}
</code></pre>
<pre><code class="language-java">// AbstractChannel.AbstractUnsafe
public final void register(EventLoop eventLoop, final ChannelPromise promise) {
    // è·å–bossGroup
    AbstractChannel.this.eventLoop = eventLoop;
    // eventLoop.inEventLoop()è¡¨ç¤ºå¯åŠ¨çº¿ç¨‹ä¸å½“å‰çº¿ç¨‹ç›¸åŒï¼Œç›¸åŒè¡¨ç¤ºå·²ç»å¯åŠ¨ï¼Œä¸åŒåˆ™æœ‰ä¸¤ç§å¯èƒ½ï¼šæœªå¯åŠ¨æˆ–è€…çº¿ç¨‹ä¸åŒ
    if (eventLoop.inEventLoop()) {
        // å¦‚æœæ˜¯åŒä¸€çº¿ç¨‹ åˆ™è°ƒç”¨æ³¨å†Œæ–¹æ³•
        register0(promise);
    } else {
        try {
            // å¦‚æœä¸æ˜¯åŒä¸€çº¿ç¨‹,åˆ™æŠŠæ³¨å†Œæ–¹æ³•æ‰§è¡ŒåŒ…è£…æˆä»»åŠ¡æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­
            eventLoop.execute(new Runnable() {
                @Override
                public void run() {
                    register0(promise);
                }
            });
        } catch (Throwable t) {
            closeForcibly();
            closeFuture.setClosed();
            safeSetFailure(promise, t);
        }
    }
}

private void register0(ChannelPromise promise) {
	try {
		// åˆ¤æ–­channelæ˜¯å¦å¤„äºæ‰“å¼€çŠ¶æ€
		if (!promise.setUncancellable() || !ensureOpen(promise)) {
			return;
		}
		// æ˜¯å¦é¦–æ¬¡æ³¨å†Œ
		boolean firstRegistration = neverRegistered;
		// ps æ­¤æ–¹æ³•å¾ˆé‡è¦,nio channelæ³¨å†Œ
		doRegister();
		// æ˜¯å¦é¦–æ¬¡æ³¨å†Œè®¾ç½®ä¸ºfalse
		neverRegistered = false;
		// å·²æ³¨å†Œè®¾ç½®ä¸ºtrue
		registered = true;

		// å¼€å§‹è°ƒç”¨handlerAddedæ–¹æ³•é“¾
		pipeline.invokeHandlerAddedIfNeeded();
		
		// è®¾ç½®ä¸ºæˆåŠŸ
		safeSetSuccess(promise);
		// è°ƒç”¨channelRegisteredæ–¹æ³•é“¾ ps:å¦‚æœæƒ³å¯åŠ¨Serverå°±è¿›è¡Œè°ƒç”¨ åˆ™æŠŠæ­¤handleråŠ å…¥åˆ°ServerBootstrap.handler
		// å¦‚æœæ˜¯ç­‰å¾…å®¢æˆ·ç«¯æ³¨å†Œåè°ƒç”¨ åˆ™æ·»åŠ åˆ°ServerBootstrap.childHandlerå³å¯
		pipeline.fireChannelRegistered();
		// åˆ¤æ–­é€šé“channelæ˜¯å¦æ‰“å¼€
		if (isActive()) {
			if (firstRegistration) {
				// å¦‚æœé€šé“channelå·²ç»æ‰“å¼€&amp;æ˜¯é¦–æ¬¡æ³¨å†Œ
				// è°ƒç”¨channelActiveæ–¹æ³•é“¾
				pipeline.fireChannelActive();
			} else if (config().isAutoRead()) {
				// æ­¤é¢‘é“ä»¥å‰å·²æ³¨å†Œï¼Œå¹¶ä¸”å·²è®¾ç½®isAutoReadã€‚è¿™æ„å‘³ç€æˆ‘ä»¬éœ€è¦é‡æ–°å¼€å§‹è¯»å–ï¼Œä»¥ä¾¿å¤„ç†å…¥ç«™æ•°æ®ã€‚ï¼ˆç¿»è¯‘ï¼‰
				// See https://github.com/netty/netty/issues/4805
				// æŠŠäº‹ä»¶è®¾ç½®ä¸ºread
				beginRead();
			}
		}
	} catch (Throwable t) {
		// Close the channel directly to avoid FD leak.
		closeForcibly();
		closeFuture.setClosed();
		safeSetFailure(promise, t);
	}
}
</code></pre>
<p>æ³¨å†Œç¯èŠ‚å°±è¯´åˆ°è¿™é‡Œ,å…³äº<code>doRegister()</code>,<code>pipeline.invokeHandlerAddedIfNeeded()</code>,<code>pipeline.fireChannelRegistered()</code>ï¼Œ<code>pipeline.fireChannelActive()</code>æ–¹æ³•å¯ä»¥è‡ªè¡Œçœ‹ä¸€ä¸‹,å’Œspringä¸­çš„æ‹¦æˆªå™¨æ‰§è¡Œæœ‰ç‚¹ç›¸ä¼¼,æ³¨å†Œæ–¹æ³•çœ‹è¿‡nioå°±èƒ½ä¸€çœ¼çœ‹æ˜ç™½</p>
</li>
</ul>
</li>
</ul>
<h5 id="åˆ†æno2dobind0regfuture-channel-localaddress-promise">åˆ†æNO.2<code>doBind0(regFuture, channel, localAddress, promise);</code></h5>
<pre><code class="language-java">private static void doBind0(
            final ChannelFuture regFuture, final Channel channel,
            final SocketAddress localAddress, final ChannelPromise promise) {
	// æ­¤æ–¹æ³•çš„è°ƒç”¨ä¼šåœ¨channelRegisteredæ–¹æ³•ä¹‹å‰,ä½†è‚¯å®šä¼šåœ¨çœŸæ­£çš„channelæ³¨å†Œåˆ°selectoræ–¹æ³•ä¹‹å
	// ä¹Ÿå°±æ˜¯è¯´bindæ–¹æ³•æ‰§è¡Œé“¾æ˜¯è¿™æ ·çš„:channel.register(selector) --&gt; 
	// 								  bind()ä¹Ÿå°±æ˜¯ä¸‹é¢çš„channel.bind --&gt; 
	// 								  handler.channelRegistered() ä¹Ÿå°±æ˜¯å¼€å§‹äº†æ‰§è¡Œé“¾
    // ç†æƒ³çŠ¶æ€æ˜¯è¿™æ ·çš„æ‰§è¡Œé“¾,å¦‚æœæ‰§è¡Œæ—¶ä¸æ˜¯åŒä¸€çº¿ç¨‹,åˆ™æ‰§è¡Œæµç¨‹ä¸æ˜¯ä¸Šé¢çš„æƒ…å†µ
	// å…³äºchannel.register(selector) å¯ä»¥åœ¨initAndRegister()æ–¹æ³•çš„ChannelFuture regFuture = config().group().register(channel);
	// è¿™è¡Œä»£ç ä¸€ç›´è·Ÿä¸‹å»å°±ä¼šå‡ºç°å¤§å®¶ç†Ÿæ‚‰çš„nioæ³¨å†Œäº†
	channel.eventLoop().execute(new Runnable() {
		@Override
		public void run() {
			if (regFuture.isSuccess()) {
				channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
			} else {
				promise.setFailure(regFuture.cause());
			}
		}
	});
}
</code></pre>
<p><code>channel.bind(localAddress, promise)</code>å…·ä½“çš„æ‰§è¡Œæ–¹æ³•ä¹Ÿæ˜¯åœ¨<code>AbstractChannel.AbstractUnsafe</code>ä¸­çš„,å…·ä½“çš„æµç¨‹,è·Ÿç€debugå°±å¯ä»¥äº†è§£åˆ°,è¿™é‡Œå°±ä¸å†™äº†</p>
<pre><code class="language-java">// AbstractChannel.AbstractUnsafe
public final void bind(final SocketAddress localAddress, final ChannelPromise promise) {
	// æˆ‘è‡ªå·±çš„ç†è§£ï¼šç»‘å®šå‰çš„çŠ¶æ€
	boolean wasActive = isActive();
	try {
		doBind(localAddress);
	} catch (Throwable t) {
		safeSetFailure(promise, t);
		closeIfClosed();
		return;
	}
	// isActive ç»‘å®šåçš„çŠ¶æ€
	if (!wasActive &amp;&amp; isActive()) {
		// å¦‚æœchannelå·²ç»Openäº†é‚£ä¹ˆå°±è¿›è¡Œäº‹ä»¶ä¼ æ’­channelActive
		invokeLater(new Runnable() {
			@Override
			public void run() {
				pipeline.fireChannelActive();
			}
		});
	}
	// è®¾ç½®å›è°ƒæ–¹æ³•ä¸ºæˆåŠŸ
	safeSetSuccess(promise);
}
</code></pre>
<p><code>doBind(localAddress)</code>æ˜¯ä¸€ä¸ªæŠ½è±¡æ–¹æ³•ç”±å­ç±»å»å®ç°ã€‚æ­¤æ–¹æ³•æ˜¯channelçš„,æ‰€ä»¥å®ç°å°±æ˜¯<code>NioServerSocketChannel</code>æ­¤ç±»</p>
<pre><code class="language-java">protected void doBind(SocketAddress localAddress) throws Exception {
	// åˆ¤æ–­å½“å‰çš„jdkç‰ˆæœ¬æ˜¯å¦ &gt;= 7  ç‰ˆæœ¬ä¸åŒ  ç»‘å®šæ–¹å¼å‘ç”Ÿäº†å˜åŒ–
	if (PlatformDependent.javaVersion() &gt;= 7) {
		javaChannel().bind(localAddress, config.getBacklog());
	} else {
		javaChannel().socket().bind(localAddress, config.getBacklog());
	}
}
</code></pre>
<h6 id="å…³äºserverçš„å‡†å¤‡é˜¶æ®µæµç¨‹å·²ç»åˆ†æå®Œæ¯•ä¸‹ä¸€ç« ä¼šåˆ†æè¿è¡Œé˜¶æ®µçš„å„ä¸ªäº‹ä»¶çš„å¤„ç†">å…³äºServerçš„å‡†å¤‡é˜¶æ®µæµç¨‹å·²ç»åˆ†æå®Œæ¯•.ä¸‹ä¸€ç« ä¼šåˆ†æè¿è¡Œé˜¶æ®µçš„å„ä¸ªäº‹ä»¶çš„å¤„ç†</h6>
<h6 id="æœ¬äººæ¸£æ¸£ä¸€æšå¯¹nettyçš„äº†è§£ä¸æ˜¯å¤ªå¤šè¿™é‡Œåªæ˜¯æ ¹æ®nio-exampleæŠŠè‡ªå·±å¯¹nettyçš„ç†è§£ç»™å†™ä¸€ä¸‹å¦‚æœæœ‰é”™æœ›æŒ‡å‡ºä¸èƒœæ„Ÿæ¿€">æœ¬äººæ¸£æ¸£ä¸€æš.å¯¹nettyçš„äº†è§£ä¸æ˜¯å¤ªå¤š,è¿™é‡Œåªæ˜¯æ ¹æ®NIO exampleæŠŠè‡ªå·±å¯¹nettyçš„ç†è§£ç»™å†™ä¸€ä¸‹,å¦‚æœæœ‰é”™æœ›æŒ‡å‡º,ä¸èƒœæ„Ÿæ¿€</h6>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://languidme.github.io//post/hello-gridea</id>
        <link href="https://languidme.github.io//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea ä¸»é¡µ</a><br>
<a href="http://fehey.com/">ç¤ºä¾‹ç½‘ç«™</a></p>
<h2 id="ç‰¹æ€§">ç‰¹æ€§ğŸ‘‡</h2>
<p>ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ <strong>Markdown</strong> è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ</p>
<p>ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡</p>
<p>ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„</p>
<p>ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•</p>
<p>ğŸ’»  ä½ å¯ä»¥åœ¨ <strong>ğ–¶ğ—‚ğ—‡ğ–½ğ—ˆğ—ğ—Œ</strong> æˆ– <strong>ğ–¬ğ–ºğ–¼ğ–®ğ–²</strong> è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯</p>
<p>ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ <strong>ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ</strong> æˆ– <strong>Coding Pages</strong> å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°</p>
<p>ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ <a href="https://github.com/gitalk/gitalk">Gitalk</a> æˆ– <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> è¯„è®ºç³»ç»Ÿ</p>
<p>ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨<strong>ä¸­æ–‡ç®€ä½“</strong>æˆ–<strong>è‹±è¯­</strong></p>
<p>ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›</p>
<p>ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥</p>
<p>ğŸŒ± å½“ç„¶ <strong>Gridea</strong> è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ğŸƒ</p>
<p>æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´</p>
<p>å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼</p>
<p>ğŸ˜˜ Enjoy~</p>
]]></content>
    </entry>
</feed>